/* rxjs@6.6.3 */
import{O as e,S as s}from"./rxjs-shared.min.js";import{S as r,N as t,a}from"./rxjs-shared.min3.js";import"./rxjs-shared.min8.js";import{V as i,a as o}from"./rxjs-shared.min5.js";class n{constructor(e,s=Number.POSITIVE_INFINITY){this.subscribedFrame=e,this.unsubscribedFrame=s}}class c{constructor(){this.subscriptions=[]}logSubscribedFrame(){return this.subscriptions.push(new n(this.scheduler.now())),this.subscriptions.length-1}logUnsubscribedFrame(e){const s=this.subscriptions,r=s[e];s[e]=new n(r.subscribedFrame,this.scheduler.now())}}function h(e,s){for(let r=0,t=s.length;r<t;r++){const t=s[r],a=Object.getOwnPropertyNames(t.prototype);for(let s=0,r=a.length;s<r;s++){const r=a[s];e.prototype[r]=t.prototype[r]}}}class b extends e{constructor(e,r){super((function(e){const r=this,t=r.logSubscribedFrame(),a=new s;return a.add(new s(()=>{r.logUnsubscribedFrame(t)})),r.scheduleMessages(e),a})),this.messages=e,this.subscriptions=[],this.scheduler=r}scheduleMessages(e){const s=this.messages.length;for(let r=0;r<s;r++){const s=this.messages[r];e.add(this.scheduler.schedule(({message:e,subscriber:s})=>{e.notification.observe(s)},s.frame,{message:s,subscriber:e}))}}}h(b,[c]);class u extends r{constructor(e,s){super(),this.messages=e,this.subscriptions=[],this.scheduler=s}_subscribe(e){const r=this,t=r.logSubscribedFrame(),a=new s;return a.add(new s(()=>{r.logUnsubscribedFrame(t)})),a.add(super._subscribe(e)),a}setup(){const e=this,s=e.messages.length;for(var r=0;r<s;r++)(()=>{var s=e.messages[r];e.scheduler.schedule(()=>{s.notification.observe(e)},s.frame)})()}}h(u,[c]);class l extends i{constructor(e){super(o,750),this.assertDeepEqual=e,this.hotObservables=[],this.coldObservables=[],this.flushTests=[],this.runMode=!1}createTime(e){const s=e.indexOf("|");if(-1===s)throw new Error('marble diagram for time should have a completion marker "|"');return s*l.frameTimeFactor}createColdObservable(e,s,r){if(-1!==e.indexOf("^"))throw new Error('cold observable cannot have subscription offset "^"');if(-1!==e.indexOf("!"))throw new Error('cold observable cannot have unsubscription marker "!"');const t=l.parseMarbles(e,s,r,void 0,this.runMode),a=new b(t,this);return this.coldObservables.push(a),a}createHotObservable(e,s,r){if(-1!==e.indexOf("!"))throw new Error('hot observable cannot have unsubscription marker "!"');const t=l.parseMarbles(e,s,r,void 0,this.runMode),a=new u(t,this);return this.hotObservables.push(a),a}materializeInnerObservable(e,s){const r=[];return e.subscribe(e=>{r.push({frame:this.frame-s,notification:t.createNext(e)})},e=>{r.push({frame:this.frame-s,notification:t.createError(e)})},()=>{r.push({frame:this.frame-s,notification:t.createComplete()})}),r}expectObservable(s,r=null){const a=[],i={actual:a,ready:!1},o=l.parseMarblesAsSubscriptions(r,this.runMode),n=o.subscribedFrame===Number.POSITIVE_INFINITY?0:o.subscribedFrame,c=o.unsubscribedFrame;let h;this.schedule(()=>{h=s.subscribe(s=>{let r=s;s instanceof e&&(r=this.materializeInnerObservable(r,this.frame)),a.push({frame:this.frame,notification:t.createNext(r)})},e=>{a.push({frame:this.frame,notification:t.createError(e)})},()=>{a.push({frame:this.frame,notification:t.createComplete()})})},n),c!==Number.POSITIVE_INFINITY&&this.schedule(()=>h.unsubscribe(),c),this.flushTests.push(i);const{runMode:b}=this;return{toBe(e,s,r){i.ready=!0,i.expected=l.parseMarbles(e,s,r,!0,b)}}}expectSubscriptions(e){const s={actual:e,ready:!1};this.flushTests.push(s);const{runMode:r}=this;return{toBe(e){const t="string"==typeof e?[e]:e;s.ready=!0,s.expected=t.map(e=>l.parseMarblesAsSubscriptions(e,r))}}}flush(){const e=this.hotObservables;for(;e.length>0;)e.shift().setup();super.flush(),this.flushTests=this.flushTests.filter(e=>!e.ready||(this.assertDeepEqual(e.actual,e.expected),!1))}static parseMarblesAsSubscriptions(e,s=!1){if("string"!=typeof e)return new n(Number.POSITIVE_INFINITY);const r=e.length;let t=-1,a=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,o=0;for(let n=0;n<r;n++){let r=o;const c=e=>{r+=e*this.frameTimeFactor},h=e[n];switch(h){case" ":s||c(1);break;case"-":c(1);break;case"(":t=o,c(1);break;case")":t=-1,c(1);break;case"^":if(a!==Number.POSITIVE_INFINITY)throw new Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");a=t>-1?t:o,c(1);break;case"!":if(i!==Number.POSITIVE_INFINITY)throw new Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");i=t>-1?t:o;break;default:if(s&&h.match(/^[0-9]$/)&&(0===n||" "===e[n-1])){const s=e.slice(n).match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(s){n+=s[0].length-1;const e=parseFloat(s[1]);let r;switch(s[2]){case"ms":r=e;break;case"s":r=1e3*e;break;case"m":r=1e3*e*60}c(r/this.frameTimeFactor);break}}throw new Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.")}o=r}return i<0?new n(a):new n(a,i)}static parseMarbles(e,s,r,a=!1,i=!1){if(-1!==e.indexOf("!"))throw new Error('conventional marble diagrams cannot have the unsubscription marker "!"');const o=e.length,n=[],c=i?e.replace(/^[ ]+/,"").indexOf("^"):e.indexOf("^");let h=-1===c?0:c*-this.frameTimeFactor;const u="object"!=typeof s?e=>e:e=>a&&s[e]instanceof b?s[e].messages:s[e];let l=-1;for(let s=0;s<o;s++){let a=h;const o=e=>{a+=e*this.frameTimeFactor};let c;const b=e[s];switch(b){case" ":i||o(1);break;case"-":o(1);break;case"(":l=h,o(1);break;case")":l=-1,o(1);break;case"|":c=t.createComplete(),o(1);break;case"^":o(1);break;case"#":c=t.createError(r||"error"),o(1);break;default:if(i&&b.match(/^[0-9]$/)&&(0===s||" "===e[s-1])){const r=e.slice(s).match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(r){s+=r[0].length-1;const e=parseFloat(r[1]);let t;switch(r[2]){case"ms":t=e;break;case"s":t=1e3*e;break;case"m":t=1e3*e*60}o(t/this.frameTimeFactor);break}}c=t.createNext(u(b)),o(1)}c&&n.push({frame:l>-1?l:h,notification:c}),h=a}return n}run(e){const s=l.frameTimeFactor,r=this.maxFrames;l.frameTimeFactor=1,this.maxFrames=Number.POSITIVE_INFINITY,this.runMode=!0,a.delegate=this;const t={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this)};try{const i=e(t);return this.flush(),i}finally{l.frameTimeFactor=s,this.maxFrames=r,this.runMode=!1,a.delegate=void 0}}}export{l as TestScheduler};
